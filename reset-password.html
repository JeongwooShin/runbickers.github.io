<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>비밀번호 재설정 | RunBickers</title>
    <meta name="description" content="RunBickers 비밀번호 재설정 페이지" />
    <link rel="canonical" href="https://jeongwooshin.github.io/runbickers.github.io/reset-password.html" />
    <style>
      :root { color-scheme: light dark; }
      body { font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Noto Sans KR, Apple SD Gothic Neo, sans-serif; margin: 0; padding: 0; background: #f7f7f8; }
      .wrap { max-width: 520px; margin: 8vh auto; padding: 24px; border-radius: 12px; background: #fff; box-shadow: 0 10px 30px rgba(0,0,0,.08); }
      h1 { font-size: 22px; margin: 0 0 16px; }
      p { line-height: 1.6; margin: 0 0 12px; }
      form { display: grid; gap: 12px; margin-top: 12px; }
      label { font-size: 14px; font-weight: 600; }
      input { width: 100%; padding: 10px 12px; border: 1px solid #d0d5dd; border-radius: 8px; font-size: 16px; }
      button { padding: 12px 14px; border: 0; border-radius: 8px; font-weight: 600; background: #4f46e5; color: white; cursor: pointer; }
      button:disabled { opacity: .6; cursor: not-allowed; }
      .notice { padding: 12px; border-radius: 8px; background: #f1f5f9; font-size: 14px; color: #0f172a; }
      .msg { padding: 10px 12px; border-radius: 8px; font-size: 14px; }
      .ok { background:#ecfdf5; color:#065f46; border:1px solid #a7f3d0 }
      .err { background:#fef2f2; color:#991b1b; border:1px solid #fecaca }
      .footer { margin-top: 16px; font-size: 12px; color: #667085; }
      .mono { font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace; word-break: break-all; white-space: pre-wrap; }
      .hidden { display: none; }
      .row { display: grid; gap: 8px; }
      .hint { color:#475569; font-size:12px; }
    </style>
    <!-- supabase-js는 동적 로딩(폴백 포함) -->
  </head>
  <body>
    <main class="wrap" role="main">
      <h1>비밀번호 재설정</h1>
      <div id="status" class="notice">이메일 링크를 확인하는 중입니다…</div>

      <!-- OTP(일회성 토큰) 모드: 이메일 + 새 비밀번호 동시 입력 -->
      <form id="otpForm" class="hidden" autocomplete="off">
        <div class="row">
          <label for="otp-email">계정 이메일</label>
          <input id="otp-email" name="email" type="email" required placeholder="가입한 이메일 주소" />
        </div>
        <div class="row">
          <label for="otp-password">새 비밀번호</label>
          <input id="otp-password" name="password" type="password" required minlength="8" placeholder="최소 8자" />
        </div>
        <div class="row">
          <label for="otp-confirm">새 비밀번호 확인</label>
          <input id="otp-confirm" name="confirm" type="password" required minlength="8" placeholder="한번 더 입력" />
        </div>
        <button id="otpBtn" type="submit">비밀번호 변경</button>
        <div class="hint">링크가 만료되었거나 자동 검증에 실패했다면 여기서 다시 시도하세요.</div>
      </form>

      <!-- 세션이 이미 있거나 bearer-only 인 경우: 비밀번호만 변경 -->
      <form id="resetForm" class="hidden" autocomplete="off">
        <div class="row">
          <label for="password">새 비밀번호</label>
          <input id="password" name="password" type="password" required minlength="8" placeholder="최소 8자" />
        </div>
        <div class="row">
          <label for="confirm">새 비밀번호 확인</label>
          <input id="confirm" name="confirm" type="password" required minlength="8" placeholder="한번 더 입력" />
        </div>
        <button id="submitBtn" type="submit">비밀번호 변경</button>
      </form>

      <p id="done" class="msg ok hidden">비밀번호가 변경되었습니다. 앱으로 돌아가 로그인해주세요.</p>
      <p id="error" class="msg err hidden"></p>

      <div class="footer">
        문제가 계속되면 비밀번호 재설정을 다시 요청하거나 관리자에게 문의하세요.
        <div id="debug" class="mono" aria-hidden="true"></div>
      </div>
    </main>

    <script>
      // 1) Supabase 프로젝트 설정
      const SUPABASE_URL = "https://sragibpyggwxbghyfuzq.supabase.co";
      const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNyYWdpYnB5Z2d3eGJnaHlmdXpxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMwMTYwMTYsImV4cCI6MjA2ODU5MjAxNn0.oOKRCaMs42f-LD8DclL_tXimCIY5OOKWuSHerIOj8-0";

      // 2) Supabase SDK 동적 로딩 + 폴백
      function loadScript(src) {
        return new Promise((resolve, reject) => {
          const s = document.createElement("script");
          s.src = src;
          s.async = true;
          s.onload = () => resolve();
          s.onerror = () => reject(new Error("Script load failed: " + src));
          document.head.appendChild(s);
        });
      }
      async function loadSupabaseSdk() {
        if (window.supabase) return;
        try {
          await loadScript("https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2");
        } catch {
          await loadScript("https://unpkg.com/@supabase/supabase-js@2");
        }
        if (!window.supabase) throw new Error("Supabase SDK를 불러오지 못했습니다.");
      }

      // 3) 클라이언트 보장 (CLIENT NOT DEFINED 방지)
      let supabaseClient = null;
      async function ensureClient() {
        if (supabaseClient) return supabaseClient;
        await loadSupabaseSdk();
        supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
          auth: { persistSession: false },
        });
        return supabaseClient;
      }

      // 4) DOM 헬퍼
      const $ = (id) => document.getElementById(id);
      const statusEl = $("status");
      const otpForm = $("otpForm");
      const resetForm = $("resetForm");
      const doneEl = $("done");
      const errorEl = $("error");
      const submitBtn = $("submitBtn");
      const otpBtn = $("otpBtn");
      const debugEl = $("debug");

      function show(el){ el.classList.remove("hidden"); }
      function hide(el){ el.classList.add("hidden"); }
      const isJWT = (t) => typeof t === "string" && t.split(".").length === 3;

      // 전역 에러 노출
      window.addEventListener("error", (e) => {
        const msg = (e && e.error && e.error.message) ? e.error.message : (e.message || String(e));
        errorEl.textContent = "Unhandled error: " + msg;
        errorEl.classList.remove("hidden");
      });
      window.addEventListener("unhandledrejection", (e) => {
        const msg = (e && e.reason && e.reason.message) ? e.reason.message : String(e.reason || e);
        errorEl.textContent = "Unhandled promise rejection: " + msg;
        errorEl.classList.remove("hidden");
      });

      // 5) URL 파라미터 수집 (검색/해시 + 해시 내부 쿼리, HashRouter 경로 정규화)
      function collectParams() {
        const url = new URL(location.href);

        // 해시 문자열 정리 (#, 그리고 #/reset-password?x=y 같은 형태 처리)
        const rawHash = url.hash.startsWith("#") ? url.hash.slice(1) : url.hash;
        let hashQueryPart = rawHash;
        if (hashQueryPart.startsWith("/")) {
          const qIdx = hashQueryPart.indexOf("?");
          hashQueryPart = qIdx >= 0 ? hashQueryPart.slice(qIdx + 1) : "";
        }
        if (hashQueryPart.startsWith("?")) hashQueryPart = hashQueryPart.slice(1);

        const sp = url.searchParams;
        const hp = new URLSearchParams(hashQueryPart);
        const get = (k) => sp.get(k) || hp.get(k);

        const out = {
          href: url.toString(),
          type: get("type"),
          code: get("code"),
          access_token: get("access_token"),
          refresh_token: get("refresh_token"),
          token: get("token"),
          token_hash: get("token_hash"),
          email: get("email"),
        };

        // 백업 파싱(해시 문자열에서 직접 추출)
        const backup = url.hash || "";
        const pick = (key) => {
          const m = backup.match(new RegExp(`${key}=([^&#]+)`));
          return m ? m[1] : null;
        };
        if (!out.access_token && backup.includes("access_token=")) out.access_token = pick("access_token");
        if (!out.refresh_token && backup.includes("refresh_token=")) out.refresh_token = pick("refresh_token");
        if (!out.type && backup.includes("type=")) out.type = pick("type");
        if (!out.code && backup.includes("code=")) out.code = pick("code");
        if (!out.token_hash && backup.includes("token_hash=")) out.token_hash = pick("token_hash");
        if (!out.token && backup.includes("token=")) out.token = pick("token");
        if (!out.email && backup.includes("email=")) out.email = pick("email");

        return out;
      }

      // 6) bearer-only(JWT access만)인 경우 REST로 비번 업데이트
      async function updatePasswordWithBearer(access_token, newPassword){
        const res = await fetch(SUPABASE_URL + "/auth/v1/user", {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
            "Accept": "application/json",
            "apikey": SUPABASE_ANON_KEY,
            "Authorization": "Bearer " + access_token,
          },
          body: JSON.stringify({ password: newPassword }),
        });
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          throw new Error(err?.msg || err?.message || ("HTTP " + res.status));
        }
      }

      // 7) OTP 검증을 호환성 높게 시도 (token, token_hash 양쪽)
      async function tryVerifyOtpAll(client, email, p) {
        const candidates = [];
        // 원본 파라미터 기반 후보 생성
        const otpFromParams =
          p.token ||
          p.token_hash ||
          (p.access_token && !isJWT(p.access_token) ? p.access_token : null);

        // 순서: token -> token_hash
        if (otpFromParams) {
          candidates.push({ kind: "token", value: otpFromParams });
          candidates.push({ kind: "token_hash", value: otpFromParams });
        }
        // 중복 제거
        const seen = new Set();
        const unique = candidates.filter(c => {
          const key = c.kind + ":" + c.value;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        });

        let lastErr = null;
        for (const c of unique) {
          try {
            const params = { type: "recovery", email };
            if (c.kind === "token") params.token = c.value;
            else params.token_hash = c.value;
            const { error } = await client.auth.verifyOtp(params);
            if (!error) return { ok: true };
            lastErr = error;
          } catch (e) {
            lastErr = e;
          }
        }
        return { ok: false, error: lastErr };
      }

      // 8) 디버그 표시
      function showDebug(p, modeGuess) {
        const tokenRaw = p.token || p.token_hash || p.access_token || "";
        const tokenPreview = tokenRaw
          ? (tokenRaw.length <= 16 ? tokenRaw : tokenRaw.slice(0,8) + "..." + tokenRaw.slice(-8))
          : "(none)";
        debugEl.textContent =
          "href: " + p.href + "\n" +
          "type: " + (p.type || "(none)") + "\n" +
          "modeGuess: " + modeGuess + "\n" +
          "has code: " + Boolean(p.code) + "\n" +
          "has refresh_token: " + Boolean(p.refresh_token) + "\n" +
          "isJWT(access_token): " + Boolean(p.access_token && isJWT(p.access_token)) + "\n" +
          "email: " + (p.email || "(none)") + "\n" +
          "tokenPreview: " + tokenPreview + "\n";
      }

      // 9) 부트스트랩
      async function bootstrap(){
        const p = collectParams();

        // 이메일 자동입력(가능 시)
        if (p.email) {
          const emailEl = document.getElementById("otp-email");
          if (emailEl) emailEl.value = p.email;
        }

        // recovery만 허용(누락 시 recovery로 간주)
        const isRecovery = (p.type || "recovery") === "recovery";
        if (!isRecovery) {
          statusEl.textContent = "이 링크는 비밀번호 재설정(recovery) 링크가 아닙니다.";
          showDebug(p, "invalid");
          return;
        }

        try {
          const client = await ensureClient();

          let mode = ""; // "session", "bearer-only", "otp-email"
          let bearerAccess = null;

          if (p.code) {
            // PKCE 코드 → 세션 교환
            const { error } = await client.auth.exchangeCodeForSession(p.code);
            if (error) throw error;
            mode = "session";
          } else {
            // 토큰 판별
            const jwt = p.access_token && isJWT(p.access_token) ? p.access_token : null;
            const otp = p.token_hash || p.token || (p.access_token && !isJWT(p.access_token) ? p.access_token : null);

            if (jwt && p.refresh_token) {
              // 완전한 JWT 쌍 → 세션 설정
              const { error } = await client.auth.setSession({
                access_token: jwt,
                refresh_token: p.refresh_token,
              });
              if (error) throw error;
              mode = "session";
            } else if (jwt && !p.refresh_token) {
              // JWT만 온 경우 → 세션 없이 Bearer로 직접 업데이트
              bearerAccess = jwt;
              mode = "bearer-only";
            } else if (otp) {
              // OTP(일회성 토큰/해시)만 온 경우
              mode = "otp-email";
            } else {
              statusEl.textContent = "유효하지 않은 링크입니다. 비밀번호 재설정을 다시 요청해주세요.";
              errorEl.textContent = "토큰 파라미터가 없습니다.(access_token/token/token_hash/code 없음)";
              errorEl.classList.remove("hidden");
              showDebug(p, "no-token");
              return;
            }
          }

          showDebug(p, mode || "(unknown)");

          // OTP 모드: email 파라미터가 있으면 자동 verifyOtp → 성공 시 바로 비밀번호 폼
          if (mode === "otp-email") {
            const autoEmail = (p.email || "").trim().toLowerCase();

            if (autoEmail) {
              statusEl.textContent = "이메일과 토큰을 확인하는 중입니다…";
              const res = await tryVerifyOtpAll(client, autoEmail, p);
              if (res.ok) {
                statusEl.textContent = "새 비밀번호를 입력하세요.";
                show(resetForm);
                attachResetFormHandler("session");
              } else {
                errorEl.textContent = (res.error && res.error.message) ? res.error.message : "토큰이 만료되었거나 유효하지 않습니다. 아래에서 다시 시도해주세요.";
                show(errorEl);
                statusEl.textContent = "계정 이메일과 새 비밀번호를 입력하세요.";
                show(otpForm);
              }
            } else {
              statusEl.textContent = "계정 이메일과 새 비밀번호를 입력하세요.";
              show(otpForm);
            }

            // OTP 폼 제출: verifyOtp + updateUser를 한 번에 처리
            otpForm.addEventListener("submit", async (e) => {
              e.preventDefault();
              hide(errorEl); hide(doneEl);
              otpBtn.disabled = true;

              const email = /** @type {HTMLInputElement} */(document.getElementById("otp-email")).value.trim().toLowerCase();
              const pw1 = /** @type {HTMLInputElement} */(document.getElementById("otp-password")).value.trim();
              const pw2 = /** @type {HTMLInputElement} */(document.getElementById("otp-confirm")).value.trim();

              if (pw1.length < 8) { errorEl.textContent = "비밀번호는 8자 이상이어야 합니다."; show(errorEl); otpBtn.disabled = false; return; }
              if (pw1 !== pw2) { errorEl.textContent = "비밀번호가 일치하지 않습니다."; show(errorEl); otpBtn.disabled = false; return; }

              try {
                const client2 = await ensureClient();
                const res2 = await tryVerifyOtpAll(client2, email, p);
                if (!res2.ok) throw res2.error || new Error("OTP 검증 실패");

                const { error: upErr } = await client2.auth.updateUser({ password: pw1 });
                if (upErr) throw upErr;

                hide(otpForm);
                statusEl.textContent = "";
                show(doneEl);
              } catch (err) {
                errorEl.textContent = err?.message || String(err);
                show(errorEl);
              } finally {
                otpBtn.disabled = false;
              }
            }, { once: true });

            // OTP 모드 처리 후 종료(사용자 입력 또는 자동 진행 대기)
            if (!resetForm.classList.contains("hidden")) {
              // 자동 검증 성공 시, resetForm 제출 핸들러도 필요
              attachResetFormHandler("session");
            }
            return;
          }

          // 세션 있음(session/bearer-only 공통) → 비밀번호 폼 노출
          statusEl.textContent = "새 비밀번호를 입력하세요.";
          show(resetForm);
          attachResetFormHandler(mode, null);

        } catch (e) {
          statusEl.textContent = "오류가 발생했습니다. 비밀번호 재설정을 다시 시도해주세요.";
          errorEl.textContent = e?.message || String(e);
          show(errorEl);
        }
      }

      // resetForm 제출 핸들러 공통 함수
      function attachResetFormHandler(mode, bearerAccess = null) {
        const alreadyBound = resetForm.getAttribute("data-bound") === "1";
        if (alreadyBound) return;
        resetForm.setAttribute("data-bound", "1");

        resetForm.addEventListener("submit", async (e) => {
          e.preventDefault();
          hide(errorEl); hide(doneEl);
          submitBtn.disabled = true;

          const pw1 = /** @type {HTMLInputElement} */(document.getElementById("password")).value.trim();
          const pw2 = /** @type {HTMLInputElement} */(document.getElementById("confirm")).value.trim();

          if (pw1.length < 8) { errorEl.textContent = "비밀번호는 8자 이상이어야 합니다."; show(errorEl); submitBtn.disabled = false; return; }
          if (pw1 !== pw2) { errorEl.textContent = "비밀번호가 일치하지 않습니다."; show(errorEl); submitBtn.disabled = false; return; }

          try {
            if (mode === "bearer-only" && bearerAccess) {
              await updatePasswordWithBearer(bearerAccess, pw1);
            } else {
              const client = await ensureClient();
              const { error } = await client.auth.updateUser({ password: pw1 });
              if (error) throw error;
            }
            hide(resetForm);
            statusEl.textContent = "";
            show(doneEl);
          } catch (err) {
            errorEl.textContent = err?.message || String(err);
            show(errorEl);
          } finally {
            submitBtn.disabled = false;
          }
        }, { once: true });
      }

      // 10) 실행
      (async () => {
        // SDK 로딩 안내(지연 시 사용자에게 표시)
        const sdkDelay = setTimeout(() => {
          if (statusEl.textContent.includes("확인하는 중")) {
            statusEl.textContent = "필요한 라이브러리를 불러오는 중입니다… 네트워크 상태를 확인해주세요.";
          }
        }, 2000);
        await ensureClient().catch((e) => {
          clearTimeout(sdkDelay);
          statusEl.textContent = "필수 스크립트 로딩에 실패했습니다. 새로고침 후 다시 시도해주세요.";
          errorEl.textContent = e?.message || String(e);
          errorEl.classList.remove("hidden");
          throw e;
        });
        clearTimeout(sdkDelay);
        await bootstrap();
      })();
    </script>
  </body>
</html>
