<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>가입 완료</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"; margin:24px; line-height:1.5; }
    .card { max-width: 720px; margin: 0 auto; border: 1px solid #ddd; border-radius: 10px; padding: 20px; background: #fff3; backdrop-filter: blur(2px); }
    h1 { margin: 0 0 6px 0; font-size: 20px; }
    .muted { color: #666; font-size: 14px; margin-top: 2px; }
    .log { margin-top: 16px; padding: 12px; border-radius: 8px; background: #f6f8fa; font-size: 13px; white-space: pre-wrap; word-break: break-all; }
    .ok  { color: #0a7f2e; }
    .warn{ color: #a15a00; }
    .err { color: #b00020; }
    .row { margin-top: 12px; }
    a.btn,button { display:inline-block; padding:10px 14px; border-radius:8px; border:1px solid #2f6feb; color:#fff; background:#2f6feb; text-decoration:none; cursor:pointer; }
    .ghost { background:transparent; color:#2f6feb; }
    .actions { display:flex; gap:8px; margin-top:14px; }
  </style>
  <script type="module">
    import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

    const SUPABASE_URL = 'https://sragibpyggwxbghyfuzq.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNyYWdpYnB5Z2d3eGJnaHlmdXpxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMwMTYwMTYsImV4cCI6MjA2ODU5MjAxNn0.oOKRCaMs42f-LD8DclL_tXimCIY5OOKWuSHerIOj8-0';

    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    const $ = (s)=>document.querySelector(s);
    const log = (m,c='')=>{ const el=document.createElement('div'); el.textContent=m; if(c) el.className=c; $('#log').appendChild(el); };

    const qs = new URLSearchParams(location.search);
    const hs = new URLSearchParams(location.hash.replace(/^#/, ''));

    // Base64URL decode with padding
    function b64urlToStr(b64url) {
      try {
        let s=b64url.replace(/-/g,'+').replace(/_/g,'/'); const pad=s.length%4; if(pad) s+='='.repeat(4-pad);
        return atob(s);
      } catch { return ''; }
    }
    function parseJwtPayload(token) {
      try { const p=token.split('.'); if(p.length<2) return null; const j=b64urlToStr(p[1]); return j?JSON.parse(j):null; } catch { return null; }
    }

    function readReferralFromUrlOrLS() {
      const fromUrl=qs.get('rc')||qs.get('ref')||qs.get('referralCode');
      const fromHash=hs.get('rc')||hs.get('ref')||hs.get('referralCode');
      const fromLS=localStorage.getItem('pendingReferralCode');
      const rc=(fromUrl||fromHash||fromLS||'').trim();
      if(rc) localStorage.setItem('pendingReferralCode', rc);
      return rc;
    }
    function readReferralFromJWT() {
      const at=hs.get('access_token'); if(!at) return '';
      const payload=parseJwtPayload(at);
      const rc=payload?.user_metadata?.referralCode||payload?.user_metadata?.referralcode||'';
      return (rc||'').trim();
    }

    async function ensureSession() {
      let { data:{ session } } = await supabase.auth.getSession();
      if (session) return session;
      const code = qs.get('code') || hs.get('code');
      if (code) {
        const { data, error } = await supabase.auth.exchangeCodeForSession(code);
        if (!error && data?.session) return data.session;
      }
      const at = hs.get('access_token'); const rt = hs.get('refresh_token');
      if (at && rt) {
        const { data, error } = await supabase.auth.setSession({ access_token: at, refresh_token: rt });
        if (!error && data?.session) return data.session;
      }
      ({ data:{ session } } = await supabase.auth.getSession());
      return session ?? null;
    }

    async function detectReferralCode() {
      let rc = readReferralFromUrlOrLS(); if (rc) return rc;
      rc = readReferralFromJWT(); if (rc) return rc;
      const session = await ensureSession();
      if (session) {
        try {
          const { data: ud } = await supabase.auth.getUser();
          const rcMeta=(ud?.user?.user_metadata?.referralCode||'').trim();
          if (rcMeta) return rcMeta;
        } catch {}
      }
      return '';
    }

    async function callViaInvoke(rc) {
      // supabase-js가 Authorization/apikey를 자동 설정
      const { data, error } = await supabase.functions.invoke('process-referral', { body: { referralCode: rc } });
      if (error) throw new Error(error.message || 'invoke failed');
      return data;
    }

    async function callViaFetch(session, rc) {
      const url1 = SUPABASE_URL.replace('.supabase.co', '.functions.supabase.co') + '/process-referral';
      const url2 = SUPABASE_URL + '/functions/v1/process-referral';
      const headers = {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${session.access_token}`,
        'apikey': SUPABASE_ANON_KEY,
      };
      const body = JSON.stringify({ referralCode: rc });

      const doFetch = async (u)=>{
        const resp = await fetch(u, { method:'POST', headers, body });
        if (!resp.ok) {
          let errText = `${resp.status} ${resp.statusText}`;
          try { const j = await resp.json(); if (j?.error) errText = j.error; } catch { try { errText = await resp.text(); } catch {} }
          throw new Error(errText);
        }
        try { return await resp.json(); } catch { return {}; }
      };

      try { return await doFetch(url1); }
      catch (e1) { return await doFetch(url2).catch(e2=>{ throw new Error(e2?.message || e1?.message || 'Function call failed'); }); }
    }

    async function applyReferralIfNeeded() {
      log('가입 인증이 완료되었습니다.', 'ok');
      log('필요 시 추천 코드 적용을 보정합니다...', '');

      const session = await ensureSession();
      if (!session) { log('세션이 없습니다. 로그인 후 다시 시도해주세요.', 'err'); return; }

      // 디버그: 토큰 길이만 표시
      const tokenLen = (session?.access_token || '').length;
      log(`세션 토큰 감지: length=${tokenLen}`, tokenLen>0?'ok':'err');

      // 인증된 사용자 메일
      try {
        const { data: me } = await supabase.auth.getUser();
        log(`인증된 사용자: ${me?.user?.email || '(unknown)'}`, 'ok');
      } catch {}

      const rc = await detectReferralCode();
      if (!rc) { log('추천 코드가 감지되지 않았습니다(rc/ref/referralCode / user_metadata / JWT).', 'warn'); return; }
      log(`감지된 추천 코드: ${rc}`, 'ok');

      // 과도한 중복 호출 회피(선택)
      try {
        const since = new Date(Date.now() - 24*60*60*1000).toISOString();
        const { data: tx } = await supabase.from('coin_transactions').select('id').gte('created_at', since).limit(1);
        if (tx && tx.length>0) { log('최근 트랜잭션 존재 → 호출 생략', 'warn'); return; }
      } catch {}

      log('추천 보상 처리 시도 중...', '');
      try {
        // 1차: invoke (권장)
        let data;
        try { data = await callViaInvoke(rc); }
        catch (e) {
          log(`invoke 실패: ${e.message}`, 'warn');
          // 2차: fetch (Authorization/apikey 강제)
          data = await callViaFetch(session, rc);
        }

        if (data?.success) {
          log(`추천 보상이 적용되었습니다. 추천인(+${data.referrerReward}), 피추천인(+${data.refereeReward})`, 'ok');
          localStorage.removeItem('pendingReferralCode');
        } else {
          log('추천 처리 결과를 확인할 수 없습니다.', 'warn');
        }
      } catch (e) {
        log(`추천 처리 실패: ${e.message}`, 'err');
      }
    }

    window.addEventListener('DOMContentLoaded', applyReferralIfNeeded);
  </script>
</head>
<body>
  <div class="card">
    <h1>가입이 완료되었습니다</h1>
    <div class="muted">Your registration has completed.</div>
    <div class="row"><div id="log" class="log" role="status" aria-live="polite"></div></div>
    <div class="actions">
      <a class="btn" href="./">앱으로 이동</a>
      <a class="btn ghost" href="./index.html">홈으로</a>
    </div>
    <div class="row muted">
      참고:
      <ul>
        <li>추천 코드는 URL(rc/ref/referralCode), 브라우저 저장소, 사용자 메타데이터, JWT payload에서 감지합니다.</li>
        <li>이미 보상이 적용된 이메일(글로벌 1회 정책)은 추가 지급되지 않습니다.</li>
      </ul>
    </div>
  </div>
</body>
</html>
